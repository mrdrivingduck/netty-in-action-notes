# 5.1 - Future

Created by : Mr Dk.

2021 / 02 / 22 0:56 ğŸŒ™

Ningbo, Zhejiang, China

---

## About

`Future` æ˜¯å¼‚æ­¥è®¡ç®—ä¸­çš„æ ¸å¿ƒæ¦‚å¿µï¼Œä»£è¡¨äº†å¼‚æ­¥è®¡ç®—çš„ç»“æœã€‚è¯¥ç±»æä¾›æˆå‘˜å‡½æ•°æ¥æ£€æŸ¥å¼‚æ­¥è®¡ç®—æ˜¯å¦å·²ç»å®Œæˆã€è·å–å¼‚æ­¥è®¡ç®—ç»“æœã€æˆ–å–æ¶ˆå¼‚æ­¥è®¡ç®—çš„æ‰§è¡Œã€‚

## JDK Future

_Netty_ ä¸­çš„ `Future` ç»§æ‰¿äº† JDK ä¸­åŸç”Ÿçš„ `Future` æ¥å£ï¼Œæ‰€ä»¥å…ˆçœ‹çœ‹ JDK åŸç”Ÿçš„ `Future` æ¥å£ã€‚`FutureTask` æ˜¯ `Future` æ¥å£çš„å®ç°ï¼ŒåŒæ—¶è¿˜å®ç°äº† `Runnable` æ¥å£ï¼Œå› æ­¤å¯ä»¥è¢«æ‰§è¡Œå™¨æ‰§è¡Œã€‚

### Definition

```java
/**
 * A {@code Future} represents the result of an asynchronous
 * computation.  Methods are provided to check if the computation is
 * complete, to wait for its completion, and to retrieve the result of
 * the computation.  The result can only be retrieved using method
 * {@code get} when the computation has completed, blocking if
 * necessary until it is ready.  Cancellation is performed by the
 * {@code cancel} method.  Additional methods are provided to
 * determine if the task completed normally or was cancelled. Once a
 * computation has completed, the computation cannot be cancelled.
 * If you would like to use a {@code Future} for the sake
 * of cancellability but not provide a usable result, you can
 * declare types of the form {@code Future<?>} and
 * return {@code null} as a result of the underlying task.
 *
 * <p>
 * <b>Sample Usage</b> (Note that the following classes are all
 * made-up.)
 * <pre> {@code
 * interface ArchiveSearcher { String search(String target); }
 * class App {
 *   ExecutorService executor = ...
 *   ArchiveSearcher searcher = ...
 *   void showSearch(final String target)
 *       throws InterruptedException {
 *     Future<String> future
 *       = executor.submit(new Callable<String>() {
 *         public String call() {
 *             return searcher.search(target);
 *         }});
 *     displayOtherThings(); // do other things while searching
 *     try {
 *       displayText(future.get()); // use future
 *     } catch (ExecutionException ex) { cleanup(); return; }
 *   }
 * }}</pre>
 *
 * The {@link FutureTask} class is an implementation of {@code Future} that
 * implements {@code Runnable}, and so may be executed by an {@code Executor}.
 * For example, the above construction with {@code submit} could be replaced by:
 *  <pre> {@code
 * FutureTask<String> future =
 *   new FutureTask<String>(new Callable<String>() {
 *     public String call() {
 *       return searcher.search(target);
 *   }});
 * executor.execute(future);}</pre>
 *
 * <p>Memory consistency effects: Actions taken by the asynchronous computation
 * <a href="package-summary.html#MemoryVisibility"> <i>happen-before</i></a>
 * actions following the corresponding {@code Future.get()} in another thread.
 *
 * @see FutureTask
 * @see Executor
 * @since 1.5
 * @author Doug Lea
 * @param <V> The result type returned by this Future's {@code get} method
 */
public interface Future<V> {

}
```

### Cancellation

è¯•å›¾å–æ¶ˆä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡çš„æ‰§è¡Œã€‚å¦‚æœä»»åŠ¡å·²ç»å®Œæˆï¼Œåˆ™å–æ¶ˆå¤±è´¥ã€‚å¦‚æœä»»åŠ¡å·²ç»å¯åŠ¨ï¼Œåˆ™å¯ä»¥é€šè¿‡å‚æ•°æ§åˆ¶æ˜¯å¦ä¸­æ–­ä»»åŠ¡çš„æ‰§è¡Œã€‚å¦‚æœä»»åŠ¡å·²ç»å®Œæˆï¼Œåˆ™ `isDone()` è¿”å› `true`ï¼›å¦‚æœä»»åŠ¡å·²ç»è¢«å–æ¶ˆï¼Œåˆ™ `isCancelled()` è¿”å› `true`ã€‚

```java
/**
 * Attempts to cancel execution of this task.  This attempt will
 * fail if the task has already completed, has already been cancelled,
 * or could not be cancelled for some other reason. If successful,
 * and this task has not started when {@code cancel} is called,
 * this task should never run.  If the task has already started,
 * then the {@code mayInterruptIfRunning} parameter determines
 * whether the thread executing this task should be interrupted in
 * an attempt to stop the task.
 *
 * <p>After this method returns, subsequent calls to {@link #isDone} will
 * always return {@code true}.  Subsequent calls to {@link #isCancelled}
 * will always return {@code true} if this method returned {@code true}.
 *
 * @param mayInterruptIfRunning {@code true} if the thread executing this
 * task should be interrupted; otherwise, in-progress tasks are allowed
 * to complete
 * @return {@code false} if the task could not be cancelled,
 * typically because it has already completed normally;
 * {@code true} otherwise
 */
boolean cancel(boolean mayInterruptIfRunning);

/**
 * Returns {@code true} if this task was cancelled before it completed
 * normally.
 *
 * @return {@code true} if this task was cancelled before it completed
 */
boolean isCancelled();

/**
 * Returns {@code true} if this task completed.
 *
 * Completion may be due to normal termination, an exception, or
 * cancellation -- in all of these cases, this method will return
 * {@code true}.
 *
 * @return {@code true} if this task completed
 */
boolean isDone();
```

### Get

ç­‰å¾… (å¯ä»¥æŒ‡å®šè¶…æ—¶æ—¶é—´) å¹¶è·å–å¼‚æ­¥ä»»åŠ¡çš„æ‰§è¡Œç»“æœã€‚

```java
/**
 * Waits if necessary for the computation to complete, and then
 * retrieves its result.
 *
 * @return the computed result
 * @throws CancellationException if the computation was cancelled
 * @throws ExecutionException if the computation threw an
 * exception
 * @throws InterruptedException if the current thread was interrupted
 * while waiting
 */
V get() throws InterruptedException, ExecutionException;

/**
 * Waits if necessary for at most the given time for the computation
 * to complete, and then retrieves its result, if available.
 *
 * @param timeout the maximum time to wait
 * @param unit the time unit of the timeout argument
 * @return the computed result
 * @throws CancellationException if the computation was cancelled
 * @throws ExecutionException if the computation threw an
 * exception
 * @throws InterruptedException if the current thread was interrupted
 * while waiting
 * @throws TimeoutException if the wait timed out
 */
V get(long timeout, TimeUnit unit)
    throws InterruptedException, ExecutionException, TimeoutException;
```

## _Netty_ Future

_Netty_ ç»§æ‰¿è‡ª `java.util.concurrent.Future`ï¼Œæ‰©å±•äº† JDK åŸç”Ÿ `Future` çš„åŠŸèƒ½ã€‚

### Definition

```java
/**
 * The result of an asynchronous operation.
 */
@SuppressWarnings("ClassNameSameAsAncestorName")
public interface Future<V> extends java.util.concurrent.Future<V> {

}
```

### Status

_Netty_ ä¸­çš„ `Future` æ·»åŠ äº†å¯¹äºå¼‚æ­¥ä»»åŠ¡æ‰§è¡ŒçŠ¶æ€çš„æ›´è¯¦ç»†çš„åŒºåˆ†ï¼Œå¯¹äºå·²ç» **å®Œæˆ** çš„ä»»åŠ¡ï¼Œ_Netty_ ä¸­çš„ `Future` å°†ç»†åˆ†ä»»åŠ¡æ˜¯å¦ **æˆåŠŸå®Œæˆ**ã€‚å¦‚æœä»»åŠ¡å®Œæˆä½†å¤±è´¥ï¼Œè¿˜å¯ä»¥è·å¾—ä»£è¡¨å¤±è´¥åŸå› çš„ `Throwable` å¯¹è±¡ã€‚

```java
/**
 * Returns {@code true} if and only if the I/O operation was completed
 * successfully.
 */
boolean isSuccess();

/**
 * returns {@code true} if and only if the operation can be cancelled via {@link #cancel(boolean)}.
 */
boolean isCancellable();

/**
 * Returns the cause of the failed I/O operation if the I/O operation has
 * failed.
 *
 * @return the cause of the failure.
 *         {@code null} if succeeded or this future is not
 *         completed yet.
 */
Throwable cause();
```

### Listeners

_Netty_ ä¸­çš„ `Future` æ·»åŠ äº†å¯¹äº **ç›‘å¬å™¨** çš„æ”¯æŒã€‚`Future` ä¸Šå¯ä»¥æ³¨å†Œè‹¥å¹²ä¸ªç›‘å¬å™¨ï¼Œå½“ `Future` çš„ `isDone()` è¿”å› `true` (å³ä»»åŠ¡å®Œæˆ) æ—¶ï¼Œå·²æ³¨å†Œçš„ç›‘å¬å™¨å°†ä¼šè¢«é€šçŸ¥ï¼Œæ³¨å†Œè¿‡çš„å›è°ƒå‡½æ•°å°†ä¼šè¢«å›è°ƒã€‚

```java
/**
 * Adds the specified listener to this future.  The
 * specified listener is notified when this future is
 * {@linkplain #isDone() done}.  If this future is already
 * completed, the specified listener is notified immediately.
 */
Future<V> addListener(GenericFutureListener<? extends Future<? super V>> listener);

/**
 * Adds the specified listeners to this future.  The
 * specified listeners are notified when this future is
 * {@linkplain #isDone() done}.  If this future is already
 * completed, the specified listeners are notified immediately.
 */
Future<V> addListeners(GenericFutureListener<? extends Future<? super V>>... listeners);

/**
 * Removes the first occurrence of the specified listener from this future.
 * The specified listener is no longer notified when this
 * future is {@linkplain #isDone() done}.  If the specified
 * listener is not associated with this future, this method
 * does nothing and returns silently.
 */
Future<V> removeListener(GenericFutureListener<? extends Future<? super V>> listener);

/**
 * Removes the first occurrence for each of the listeners from this future.
 * The specified listeners are no longer notified when this
 * future is {@linkplain #isDone() done}.  If the specified
 * listeners are not associated with this future, this method
 * does nothing and returns silently.
 */
Future<V> removeListeners(GenericFutureListener<? extends Future<? super V>>... listeners);
```

### Synchronization

é˜»å¡ç­‰å¾… `Future` å¯¹åº”å¼‚æ­¥ä»»åŠ¡å®Œæˆã€‚

```java
/**
 * Waits for this future until it is done, and rethrows the cause of the failure if this future
 * failed.
 */
Future<V> sync() throws InterruptedException;

/**
 * Waits for this future until it is done, and rethrows the cause of the failure if this future
 * failed.
 */
Future<V> syncUninterruptibly();

/**
 * Waits for this future to be completed.
 *
 * @throws InterruptedException
 *         if the current thread was interrupted
 */
Future<V> await() throws InterruptedException;

/**
 * Waits for this future to be completed without
 * interruption.  This method catches an {@link InterruptedException} and
 * discards it silently.
 */
Future<V> awaitUninterruptibly();

/**
 * Waits for this future to be completed within the
 * specified time limit.
 *
 * @return {@code true} if and only if the future was completed within
 *         the specified time limit
 *
 * @throws InterruptedException
 *         if the current thread was interrupted
 */
boolean await(long timeout, TimeUnit unit) throws InterruptedException;

/**
 * Waits for this future to be completed within the
 * specified time limit.
 *
 * @return {@code true} if and only if the future was completed within
 *         the specified time limit
 *
 * @throws InterruptedException
 *         if the current thread was interrupted
 */
boolean await(long timeoutMillis) throws InterruptedException;

/**
 * Waits for this future to be completed within the
 * specified time limit without interruption.  This method catches an
 * {@link InterruptedException} and discards it silently.
 *
 * @return {@code true} if and only if the future was completed within
 *         the specified time limit
 */
boolean awaitUninterruptibly(long timeout, TimeUnit unit);

/**
 * Waits for this future to be completed within the
 * specified time limit without interruption.  This method catches an
 * {@link InterruptedException} and discards it silently.
 *
 * @return {@code true} if and only if the future was completed within
 *         the specified time limit
 */
boolean awaitUninterruptibly(long timeoutMillis);
```

### Get Now

ä»¥éé˜»å¡çš„æ–¹å¼è·å–å¼‚æ­¥ä»»åŠ¡çš„æ‰§è¡Œç»“æœã€‚å¦‚æœå¼‚æ­¥ä»»åŠ¡è¿˜æ²¡æœ‰å®Œæˆï¼Œé‚£ä¹ˆè¿”å› `null`ã€‚

```java
/**
 * Return the result without blocking. If the future is not done yet this will return {@code null}.
 *
 * As it is possible that a {@code null} value is used to mark the future as successful you also need to check
 * if the future is really done with {@link #isDone()} and not rely on the returned {@code null} value.
 */
V getNow();
```

## Abstract Future

å®ç°äº† `Future` æ¥å£çš„æŠ½è±¡ç±»ã€‚

### Definition

```java
/**
 * Abstract {@link Future} implementation which does not allow for cancellation.
 *
 * @param <V>
 */
public abstract class AbstractFuture<V> implements Future<V> {

}
```

### Get

å®ç°äº†è¶…æ—¶ä¸éè¶…æ—¶ç‰ˆæœ¬çš„ `get()`ã€‚é¦–å…ˆé˜»å¡ç­‰å¾…ä»»åŠ¡ç»“æŸï¼Œç„¶åæ ¹æ®ä»»åŠ¡æ˜¯å¦æŠ›å‡ºäº† `Throwable` å¯¹è±¡æ¥åˆ¤æ–­ä»»åŠ¡æ˜¯å¦æˆåŠŸå®Œæˆã€‚å¦‚æœä»»åŠ¡æˆåŠŸå®Œæˆï¼Œé‚£ä¹ˆè°ƒç”¨éé˜»å¡ç‰ˆæœ¬çš„ `getNow()` è·å–ä»»åŠ¡çš„æ‰§è¡Œç»“æœå¹¶è¿”å›ã€‚

```java
@Override
public V get() throws InterruptedException, ExecutionException {
    await();

    Throwable cause = cause();
    if (cause == null) {
        return getNow();
    }
    if (cause instanceof CancellationException) {
        throw (CancellationException) cause;
    }
    throw new ExecutionException(cause);
}

@Override
public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
    if (await(timeout, unit)) {
        Throwable cause = cause();
        if (cause == null) {
            return getNow();
        }
        if (cause instanceof CancellationException) {
            throw (CancellationException) cause;
        }
        throw new ExecutionException(cause);
    }
    throw new TimeoutException();
}
```
